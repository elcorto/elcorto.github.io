
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pwtools.rbf &#8212; pwtools  documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.png" alt="Logo"/>
    
    <h1 class="logo logo-name">pwtools</h1>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=elcorto&repo=pwtools&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../generated/api/index.html">API Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../written/features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/background/index.html">Background, details, special topics</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pwtools.rbf</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Radial Basis Function N-dim fitting. See :ref:`rbf` for details.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">optimize</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">linalg</span>

<span class="kn">from</span> <span class="nn">pwtools</span> <span class="k">import</span> <span class="n">num</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="k">import</span> <span class="n">RepeatedKFold</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">RepeatedKFold</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Failed to import RepeatedKFold from &quot;</span>
                                      <span class="s2">&quot;sklearn, not installed?&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="rbf_gauss"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.rbf_gauss.html#pwtools.rbf.rbf_gauss">[docs]</a><span class="k">def</span> <span class="nf">rbf_gauss</span><span class="p">(</span><span class="n">rsq</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gaussian RBF :math:`\exp\left(-\frac{r^2}{2\,p^2}\right)`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rsq : float</span>
<span class="sd">        squared distance :math:`r^2`</span>
<span class="sd">    p : float</span>
<span class="sd">        width</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">rsq</span> <span class="o">/</span> <span class="n">p</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span></div>


<div class="viewcode-block" id="rbf_multi"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.rbf_multi.html#pwtools.rbf.rbf_multi">[docs]</a><span class="k">def</span> <span class="nf">rbf_multi</span><span class="p">(</span><span class="n">rsq</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Multiquadric RBF :math:`\sqrt{r^2 + p^2}`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rsq : float</span>
<span class="sd">        squared distance :math:`r^2`</span>
<span class="sd">    p : float</span>
<span class="sd">        width</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rsq</span> <span class="o">+</span> <span class="n">p</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span></div>


<div class="viewcode-block" id="rbf_inv_multi"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.rbf_inv_multi.html#pwtools.rbf.rbf_inv_multi">[docs]</a><span class="k">def</span> <span class="nf">rbf_inv_multi</span><span class="p">(</span><span class="n">rsq</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Inverse Multiquadric RBF :math:`\frac{1}{\sqrt{r^2 + p^2}}`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rsq : float</span>
<span class="sd">        squared distance :math:`r^2`</span>
<span class="sd">    p : float</span>
<span class="sd">        width</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">rbf_multi</span><span class="p">(</span><span class="n">rsq</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></div>


<span class="n">rbf_dct</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;gauss&#39;</span><span class="p">:</span> <span class="n">rbf_gauss</span><span class="p">,</span>
    <span class="s1">&#39;multi&#39;</span><span class="p">:</span> <span class="n">rbf_multi</span><span class="p">,</span>
    <span class="s1">&#39;inv_multi&#39;</span><span class="p">:</span> <span class="n">rbf_inv_multi</span><span class="p">,</span>
    <span class="p">}</span>


<div class="viewcode-block" id="Rbf"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.Rbf.html#pwtools.rbf.Rbf">[docs]</a><span class="k">class</span> <span class="nc">Rbf</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Radial basis function network interpolation and fitting.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">rbf</span><span class="o">=</span><span class="s1">&#39;inv_multi&#39;</span><span class="p">,</span>
                 <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lin_solver</span><span class="o">=</span><span class="s1">&#39;dsysv&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : 2d array, (M,N)</span>
<span class="sd">            data points : M points in N-dim space, training set points</span>
<span class="sd">        values : 1d array, (M,)</span>
<span class="sd">            function values at training points</span>
<span class="sd">        rbf : str (see rbf_dct.keys()) or callable rbf(r**2, p)</span>
<span class="sd">        r : float or None</span>
<span class="sd">            regularization parameter, if None then we use a least squares</span>
<span class="sd">            solver</span>
<span class="sd">        p : &#39;mean&#39; or &#39;scipy&#39; (see :func:`estimate_p`) or float</span>
<span class="sd">            the RBF&#39;s free parameter</span>
<span class="sd">        lin_solver : str</span>
<span class="sd">            Linear solver method in case `r` is given</span>

<span class="sd">            | solve : :func:`scipy.linalg.solve`</span>
<span class="sd">            | dsysv : :func:`scipy.linalg.lapack.dsysv` (symmetric G)</span>
<span class="sd">            | dposv : :func:`scipy.linalg.lapack.dposv` (positive definite G)</span>
<span class="sd">        fit : bool</span>
<span class="sd">            call self.fit() in __init__</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pwtools import mpl, rbf</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; # 1D example w/ derivatives. For 1d, we need to use points[:,None]</span>
<span class="sd">        &gt;&gt;&gt; # input array containing training (dd.DY) and interpolation</span>
<span class="sd">        &gt;&gt;&gt; # (ddi.XY) points must be 2d.</span>
<span class="sd">        &gt;&gt;&gt; fig,ax = mpl.fig_ax()</span>
<span class="sd">        &gt;&gt;&gt; x=linspace(0,10,20)     # shape (M,), M=20 points</span>
<span class="sd">        &gt;&gt;&gt; z=sin(x)                # shape (M,)</span>
<span class="sd">        &gt;&gt;&gt; rbfi=rbf.Rbf(x[:,None],z)</span>
<span class="sd">        &gt;&gt;&gt; xi=linspace(0,10,100)   # shape (M,), M=100 points</span>
<span class="sd">        &gt;&gt;&gt; ax.plot(x,z,&#39;o&#39;, label=&#39;data&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax.plot(xi, sin(xi), label=&#39;sin(x)&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax.plot(xi, rbfi(xi[:,None]), label=&#39;rbf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax.plot(xi, cos(xi), label=&#39;cos(x)&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax.plot(xi, rbfi(xi[:,None],der=1)[:,0], label=&#39;d(rbf)/dx&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax.legend()</span>
<span class="sd">        &gt;&gt;&gt; # 2D example</span>
<span class="sd">        &gt;&gt;&gt; x = np.linspace(-3,3,10)</span>
<span class="sd">        &gt;&gt;&gt; dd = mpl.Data2D(x=x, y=x)</span>
<span class="sd">        &gt;&gt;&gt; dd.update(Z=np.sin(dd.X)+np.cos(dd.Y))</span>
<span class="sd">        &gt;&gt;&gt; rbfi=rbf.Rbf(dd.XY, dd.zz)</span>
<span class="sd">        &gt;&gt;&gt; xi=linspace(-3,3,50)</span>
<span class="sd">        &gt;&gt;&gt; ddi = mpl.Data2D(x=xi, y=xi)</span>
<span class="sd">        &gt;&gt;&gt; fig1,ax1 = mpl.fig_ax3d()</span>
<span class="sd">        &gt;&gt;&gt; ax1.scatter(dd.xx, dd.yy, dd.zz, label=&#39;data&#39;, color=&#39;r&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax1.plot_wireframe(ddi.X, ddi.Y, rbfi(ddi.XY).reshape(50,50),</span>
<span class="sd">        ...                    label=&#39;rbf&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax1.set_xlabel(&#39;x&#39;); ax1.set_ylabel(&#39;y&#39;);</span>
<span class="sd">        &gt;&gt;&gt; ax1.legend()</span>
<span class="sd">        &gt;&gt;&gt; fig2,ax2 = mpl.fig_ax3d()</span>
<span class="sd">        &gt;&gt;&gt; offset=2</span>
<span class="sd">        &gt;&gt;&gt; ax2.plot_wireframe(ddi.X, ddi.Y, rbfi(ddi.XY).reshape(50,50),</span>
<span class="sd">        ...                    label=&#39;rbf&#39;, color=&#39;b&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax2.plot_wireframe(ddi.X, ddi.Y,</span>
<span class="sd">        ...                    rbfi(ddi.XY, der=1)[:,0].reshape(50,50)+offset,</span>
<span class="sd">        ...                    color=&#39;g&#39;, label=&#39;d(rbf)/dx&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax2.plot_wireframe(ddi.X, ddi.Y,</span>
<span class="sd">        ...                    rbfi(ddi.XY, der=1)[:,1].reshape(50,50)+2*offset,</span>
<span class="sd">        ...                    color=&#39;r&#39;, label=&#39;d(rbf)/dy&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ax2.set_xlabel(&#39;x&#39;); ax2.set_ylabel(&#39;y&#39;);</span>
<span class="sd">        &gt;&gt;&gt; ax2.legend()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rbf</span> <span class="o">=</span> <span class="n">rbf_dct</span><span class="p">[</span><span class="n">rbf</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rbf</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">rbf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_ndim_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_ndim_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distsq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                <span class="c1"># re-implement the &#39;mean&#39; case here again since we can re-use</span>
                <span class="c1"># distsq later (training data distance matrix)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distsq</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distsq</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">p</span> <span class="o">==</span> <span class="s1">&#39;scipy&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">estimate_p</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="s1">&#39;scipy&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;p is not &#39;mean&#39; or &#39;scipy&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lin_solver</span> <span class="o">=</span> <span class="n">lin_solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lin_solvers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">solve</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_solve_general</span><span class="p">,</span>
                <span class="n">dsysv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_solve_dsysv</span><span class="p">,</span>
                <span class="n">dposv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_solve_dposv</span><span class="p">,</span>
                <span class="n">lstsq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_solve_lstsq</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">fit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_assert_ndim_points</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;points not 2d array&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_assert_ndim_values</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;values not 1d array&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Rbf.get_distsq"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.Rbf.get_distsq.html#pwtools.rbf.Rbf.get_distsq">[docs]</a>    <span class="k">def</span> <span class="nf">get_distsq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Matrix of distance values :math:`R_{ij} = |\mathbf x_i - \mathbf</span>
<span class="sd">        c_j|`.</span>

<span class="sd">            | :math:`\mathbf x_i` : ``points[i,:]``      (points)</span>
<span class="sd">            | :math:`\mathbf c_j` : ``self.points[j,:]`` (centers)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : array (K,N) with N-dim points, optional</span>
<span class="sd">            If None then ``self.points`` is used (training points).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        distsq : (M,K), where K = M for training</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pure numpy:</span>
        <span class="c1">#     dist = points[:,None,...] - centers[None,...]</span>
        <span class="c1">#     distsq = (dist**2.0).sum(axis=-1)</span>
        <span class="c1"># where</span>
        <span class="c1">#     points:  (M,N)</span>
        <span class="c1">#     centers: (K,N)</span>
        <span class="c1">#     dist:    (M,K,N) &quot;matrix&quot; of distance vectors (only for numpy case)</span>
        <span class="c1">#     distsq:  (M,K)    matrix of squared distance values</span>
        <span class="c1"># Creates *big* temporary arrays if points is big (~1e4 points).</span>
        <span class="c1">#</span>
        <span class="c1"># training:</span>
        <span class="c1">#     If points == centers, we could also use</span>
        <span class="c1">#     scipy.spatial.distance.pdist(points), which would give us a 1d</span>
        <span class="c1">#     array of all distances. But we need the redundant square matrix</span>
        <span class="c1">#     form for G=rbf(distsq) anyway, so there is no real point in</span>
        <span class="c1">#     special-casing that. These two are the same:</span>
        <span class="c1">#      &gt;&gt;&gt; R = spatial.squareform(spatial.distances.pdist(points))</span>
        <span class="c1">#      &gt;&gt;&gt; R = spatial.distances.cdist(points,points)</span>
        <span class="c1">#      &gt;&gt;&gt; distsq = R**2</span>
        <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distsq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num</span><span class="o">.</span><span class="n">distsq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distsq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">num</span><span class="o">.</span><span class="n">distsq</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rbf.get_params"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.Rbf.get_params.html#pwtools.rbf.Rbf.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``(p,r)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span></div>

<div class="viewcode-block" id="Rbf.fit"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.Rbf.fit.html#pwtools.rbf.Rbf.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Solve linear system for the weights.</span>

<span class="sd">        The weights  `self.w` (:math:`\mathbf w`) are found from: :math:`\mathbf</span>
<span class="sd">        G\,\mathbf w = \mathbf z` or if :math:`r` is given :math:`(\mathbf G +</span>
<span class="sd">        r\,\mathbf I)\,\mathbf w = \mathbf z`.</span>

<span class="sd">        with centers == points (center vectors are all data points). Then G is</span>
<span class="sd">        quadratic. Updates ``self.w``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ``self.r != None`` : linear system solver</span>
<span class="sd">            Use `lin_solver`. For :math:`r=0`, this always yields</span>
<span class="sd">            perfect interpolation at the data points. May be numerically</span>
<span class="sd">            unstable in that case. Use :math:`r&gt;0` to increase stability (try</span>
<span class="sd">            small values such as ``1e-10`` first) or create smooth fitting (generate</span>
<span class="sd">            more stiff functions with higher `r`). Behaves similar to ``lstsq``</span>
<span class="sd">            but appears to be numerically more stable (no small noise in</span>
<span class="sd">            solution) .. but `r` it is another parameter that needs to be</span>
<span class="sd">            tuned.</span>
<span class="sd">        ``self.r = None`` : least squares solver</span>
<span class="sd">            Use :func:`scipy.linalg.lstsq`. Numerically more stable than</span>
<span class="sd">            direct solver w/o regularization. Will mostly be the same as</span>
<span class="sd">            the interpolation result, but will not go thru all points for</span>
<span class="sd">            very noisy data. May create small noise in solution (plot fit</span>
<span class="sd">            with high point density). Also slower that e.g. ``dsysv``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rbf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_distsq</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">G</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span><span class="o">*</span><span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lin_solvers</span><span class="p">[</span><span class="s1">&#39;lstsq&#39;</span><span class="p">](</span><span class="n">G</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lin_solvers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lin_solver</span><span class="p">](</span><span class="n">G</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_solve_lstsq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rnk</span><span class="p">,</span> <span class="n">svs</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="c1"># Generally shaped G</span>
    <span class="k">def</span> <span class="nf">_solve_general</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Gr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Gr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="c1"># G symmetric</span>
    <span class="k">def</span> <span class="nf">_solve_dsysv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Gr</span><span class="p">):</span>
        <span class="n">udut</span><span class="p">,</span><span class="n">ipiv</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">info</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lapack</span><span class="o">.</span><span class="n">dsysv</span><span class="p">(</span><span class="n">Gr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;info=</span><span class="si">{info}</span><span class="s2">: singular matrix&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">info</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;illegal input for </span><span class="si">{info}</span><span class="s2">-th argument&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="c1"># G positive definite</span>
    <span class="k">def</span> <span class="nf">_solve_dposv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Gr</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">info</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lapack</span><span class="o">.</span><span class="n">dposv</span><span class="p">(</span><span class="n">Gr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;info=</span><span class="si">{info}</span><span class="s2">: not positive definite&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">info</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;illegal input for </span><span class="si">{info}</span><span class="s2">-th argument&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<div class="viewcode-block" id="Rbf.interpolate"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.Rbf.interpolate.html#pwtools.rbf.Rbf.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate interpolant at `points`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : see :meth:`__call__`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vals : 1d array (points.shape[0],)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_ndim_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">distsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distsq</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rbf</span><span class="p">(</span><span class="n">distsq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span> \
               <span class="s2">&quot;shape mismatch between g_ij: </span><span class="si">%s</span><span class="s2"> and w_j: </span><span class="si">%s</span><span class="s2">, 2nd dim of &quot;</span>\
               <span class="s2">&quot;g_ij must match length of w_j&quot;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                                 <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="c1"># normalize w</span>
        <span class="n">maxw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">/</span> <span class="n">maxw</span><span class="p">)</span> <span class="o">*</span> <span class="n">maxw</span></div>

<div class="viewcode-block" id="Rbf.deriv"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.Rbf.deriv.html#pwtools.rbf.Rbf.deriv">[docs]</a>    <span class="k">def</span> <span class="nf">deriv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Matrix of partial first derivatives.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : 2d array (L,N)</span>
<span class="sd">            See also :meth:`__call__`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2d array (L,N)</span>
<span class="sd">            Each row holds the gradient vector :math:`\partial f/\partial\mathbf x_i`</span>
<span class="sd">            where :math:`\mathbf x_i = \texttt{points[i,:]</span>
<span class="sd">            = [xi_0, ..., xi_N-1]}`. For all points points (L,N) we get the</span>
<span class="sd">            matrix::</span>

<span class="sd">                [[df/dx0_0,   df/dx0_1,   ..., df/dx0_N-1],</span>
<span class="sd">                 [...],</span>
<span class="sd">                 [df/dxL-1_0, df/dxL-1_1, ..., df/dxL-1_N-1]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For the implemented RBF types, the derivatives w.r.t. to the point</span>
        <span class="c1"># coords simplify to nice dot products, which can be evaluated</span>
        <span class="c1"># reasonably fast w/ numpy. We don&#39;t need to change the RBF&#39;s</span>
        <span class="c1"># implementations to provide a deriv() method. For that, they would</span>
        <span class="c1"># need to take points and centers explicitly as args instead of squared</span>
        <span class="c1"># distances, which are calculated fast by Fortran outside.</span>
        <span class="c1">#</span>
        <span class="c1"># Speed:</span>
        <span class="c1"># We have one python loop over the L points (points.shape=(L,N)) left, so</span>
        <span class="c1"># this gets slow for many points.</span>
        <span class="c1">#</span>
        <span class="c1"># Loop versions (for RBFMultiquadric):</span>
        <span class="c1">#</span>
        <span class="c1"># # 3 loops:</span>
        <span class="c1"># D = np.zeros((L,N), dtype=float)</span>
        <span class="c1"># for ll in range(L):</span>
        <span class="c1">#     for kk in range(N):</span>
        <span class="c1">#         for jj in range(len(self.w)):</span>
        <span class="c1">#             D[ll,kk] += (points[ll,kk] - centers[jj,kk]) / G[ll,jj] * \</span>
        <span class="c1">#                 self.w[jj]</span>
        <span class="c1">#</span>
        <span class="c1"># # 2 loops:</span>
        <span class="c1"># D = np.zeros((L,N), dtype=float)</span>
        <span class="c1"># for ll in range(L):</span>
        <span class="c1">#     for kk in range(N):</span>
        <span class="c1">#         vec = -1.0 * (centers[:,kk] - points[ll,kk]) / G[ll,:]</span>
        <span class="c1">#         D[ll,kk] = np.dot(vec, self.w)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_ndim_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">L</span><span class="p">,</span><span class="n">N</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>
        <span class="n">distsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distsq</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rbf</span><span class="p">(</span><span class="n">distsq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">L</span><span class="p">,</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">maxw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rbf</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">fname</span> <span class="o">==</span> <span class="s1">&#39;rbf_multi&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">zz</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
                <span class="n">D</span><span class="p">[</span><span class="n">zz</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(((</span><span class="n">centers</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">zz</span><span class="p">,:])</span> <span class="o">/</span> <span class="n">G</span><span class="p">[</span><span class="n">zz</span><span class="p">,:][:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">/</span> <span class="n">maxw</span><span class="p">)</span> <span class="o">*</span> <span class="n">maxw</span>
        <span class="k">elif</span> <span class="n">fname</span> <span class="o">==</span> <span class="s1">&#39;rbf_inv_multi&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">zz</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
                <span class="n">D</span><span class="p">[</span><span class="n">zz</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(((</span><span class="n">centers</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">zz</span><span class="p">,:])</span> <span class="o">*</span> <span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">zz</span><span class="p">,:]</span><span class="o">**</span><span class="mf">3.0</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">/</span> <span class="n">maxw</span><span class="p">)</span> <span class="o">*</span> <span class="n">maxw</span>
        <span class="k">elif</span> <span class="n">fname</span> <span class="o">==</span> <span class="s1">&#39;rbf_gauss&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">zz</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
                <span class="n">D</span><span class="p">[</span><span class="n">zz</span><span class="p">,:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">*</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(((</span><span class="n">centers</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">zz</span><span class="p">,:])</span> <span class="o">*</span> <span class="n">G</span><span class="p">[</span><span class="n">zz</span><span class="p">,:][:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">/</span> <span class="n">maxw</span><span class="p">)</span> <span class="o">*</span> <span class="n">maxw</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;derivative not implemented for function: </span><span class="si">{fname}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">D</span></div>

<div class="viewcode-block" id="Rbf.fit_error"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.Rbf.fit_error.html#pwtools.rbf.Rbf.fit_error">[docs]</a>    <span class="k">def</span> <span class="nf">fit_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sum of squared fit errors with penalty on negative `p`.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">values</span> <span class="o">-</span> <span class="bp">self</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">res</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">err</span></div>

<div class="viewcode-block" id="Rbf.__call__"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.Rbf.__call__.html#pwtools.rbf.Rbf.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call :meth:`interpolate` or :meth:`deriv`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : 2d array (L,N)</span>
<span class="sd">            L N-dim points to evaluate the interpolant on.</span>
<span class="sd">        der : int</span>
<span class="sd">            If == 1 return matrix of partial derivatives (see :meth:`deriv`), else</span>
<span class="sd">            interpolated values values (default).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vals : 1d array (L,)</span>
<span class="sd">            Interpolated values.</span>
<span class="sd">        or</span>
<span class="sd">        derivs : 2d array (L,N)</span>
<span class="sd">            1st partial derivatives.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;der&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;der&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;only der=1 supported&quot;</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;der&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deriv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="estimate_p"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.estimate_p.html#pwtools.rbf.estimate_p">[docs]</a><span class="k">def</span> <span class="nf">estimate_p</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Estimate :math:`p`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    method : str</span>
<span class="sd">        | &#39;mean&#39; : :math:`1/M^2\,\sum_{ij} R_{ij}; M=\texttt{points.shape[0]}`</span>
<span class="sd">        | &#39;scipy&#39; : mean nearest neighbor distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num</span><span class="o">.</span><span class="n">distsq</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">points</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;scipy&#39;</span><span class="p">:</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ximax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ximin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">ximax</span> <span class="o">-</span> <span class="n">ximin</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">edges</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="o">/</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">edges</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;illegal method: </span><span class="si">{method}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="FitError"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.FitError.html#pwtools.rbf.FitError">[docs]</a><span class="k">class</span> <span class="nc">FitError</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Direct or cross-validation (CV) fit error of :class:`Rbf` for a</span>
<span class="sd">    parameter set ``[p,r]`` or just ``[p]``.</span>

<span class="sd">    All methods accept a sequence `params` with either only `p` (length 1) or</span>
<span class="sd">    `p` and `r` (length 2) to build a :class:`Rbf` model and fit it.</span>

<span class="sd">    examples:</span>

<span class="sd">        | r = None (default in :class:`Rbf`) -&gt; linear least squares solver</span>
<span class="sd">        |     params = [1.5]</span>
<span class="sd">        |     params = [1.5, None]</span>

<span class="sd">        | r != None -&gt; normal linear solver</span>
<span class="sd">        |     params = [1.5, 0]       -&gt; no regularization (r=0)</span>
<span class="sd">        |     params = [1.5, 1e-8]    -&gt; with regularization</span>

<span class="sd">    Use :meth:`err_cv` or :meth:`err_direct` as error metric for `param`. Or</span>
<span class="sd">    use :meth:`__call__` which will call one or the other, depending on</span>
<span class="sd">    `params`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">rbf_kwds</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
                 <span class="n">cv_kwds</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points, values : see :class:`Rbf`</span>
<span class="sd">        rbf_kwds : dict</span>
<span class="sd">            for ``Rbf(points, values, **rbf_kwds)``</span>
<span class="sd">        cv_kwds : {dict, None}, optional</span>
<span class="sd">            cross-validation parameters for</span>
<span class="sd">            :class:`sklearn.model_selection.RepeatedKFold`), if None then</span>
<span class="sd">            :meth:`__call__` will use :meth:`err_direct`, else :meth:`err_cv`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rbf_kwds</span> <span class="o">=</span> <span class="n">rbf_kwds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_kwds</span> <span class="o">=</span> <span class="n">cv_kwds</span>

<div class="viewcode-block" id="FitError.__call__"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.FitError.__call__.html#pwtools.rbf.FitError.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_direct</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_cv</span><span class="p">(</span><span class="n">params</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_rbfi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">points</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">values</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="s1">&#39;p&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rbf_kwds</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="s2">&quot;&#39;p&#39; in kwds&quot;</span>
            <span class="k">return</span> <span class="n">Rbf</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">rbf_kwds</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="n">kw</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rbf_kwds</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">f</span><span class="s2">&quot;&#39;</span><span class="si">{kw}</span><span class="s2">&#39; in kwds&quot;</span>
            <span class="k">return</span> <span class="n">Rbf</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">rbf_kwds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;length of params can only be 1 or 2, got &quot;</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)))</span>

<div class="viewcode-block" id="FitError.cv"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.FitError.cv.html#pwtools.rbf.FitError.cv">[docs]</a>    <span class="k">def</span> <span class="nf">cv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;K-fold repeated CV.</span>

<span class="sd">        Split data (points, values) randomly into K parts (&quot;folds&quot;, K =</span>
<span class="sd">        ``n_splits`` in ``self.cv_kwds``) along axis 0 and use each part once</span>
<span class="sd">        as test set, the rest as training set. For example `ns=5`: split in 5</span>
<span class="sd">        parts at random indices, use 5 times 4/5 data for train, 1/5 for test</span>
<span class="sd">        (each of the folds), so 5 fits total -&gt; 5 fit errors. Optionally repeat</span>
<span class="sd">        ``n_repeats`` times with different random splits. So, `n_repeats` *</span>
<span class="sd">        `n_splits` fit errors total.</span>

<span class="sd">        Each time, build an Rbf interpolator with ``self.rbf_kwds``, fit,</span>
<span class="sd">        return the fit error (scalar sum of squares from</span>
<span class="sd">        :meth:`Rbf.fit_error`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : seq length 1 or 2</span>
<span class="sd">            | params[0] = p</span>
<span class="sd">            | params[1] = r (optional)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        errs : 1d array (n_repeats * n_splits,)</span>
<span class="sd">            direct fit error from each fold</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_kwds</span><span class="p">[</span><span class="s1">&#39;n_splits&#39;</span><span class="p">]</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_kwds</span><span class="p">[</span><span class="s1">&#39;n_repeats&#39;</span><span class="p">]</span>
        <span class="n">errs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">ns</span><span class="o">*</span><span class="n">nr</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">folds</span> <span class="o">=</span> <span class="n">RepeatedKFold</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_kwds</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="n">idxs_train</span><span class="p">,</span> <span class="n">idxs_test</span> <span class="o">=</span> <span class="n">tup</span>
            <span class="n">rbfi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_rbfi</span><span class="p">(</span><span class="n">params</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">idxs_train</span><span class="p">,</span><span class="o">...</span><span class="p">],</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">idxs_train</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
            <span class="n">errs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">rbfi</span><span class="o">.</span><span class="n">fit_error</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">idxs_test</span><span class="p">,</span><span class="o">...</span><span class="p">],</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">idxs_test</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">errs</span></div>

<div class="viewcode-block" id="FitError.err_cv"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.FitError.err_cv.html#pwtools.rbf.FitError.err_cv">[docs]</a>    <span class="k">def</span> <span class="nf">err_cv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Median of :meth:`cv`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="p">(</span><span class="n">params</span><span class="p">))</span></div>

<div class="viewcode-block" id="FitError.err_direct"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.FitError.err_direct.html#pwtools.rbf.FitError.err_direct">[docs]</a>    <span class="k">def</span> <span class="nf">err_direct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normal fit error w/o CV. Uses :meth:`Rbf.fit_error`.</span>

<span class="sd">        Build and Rbf interpolator with ``self.rbf_kwds``, fit, return the fit</span>
<span class="sd">        error (scalar, sum of squares). Should be zero for interpolation, i.e. no</span>
<span class="sd">        regularization ``r=0``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_rbfi</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">fit_error</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="fit_opt"><a class="viewcode-back" href="../../generated/api/pwtools.rbf.fit_opt.html#pwtools.rbf.fit_opt">[docs]</a><span class="k">def</span> <span class="nf">fit_opt</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;de&#39;</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s1">&#39;pr&#39;</span><span class="p">,</span> <span class="n">cv_kwds</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
            <span class="n">n_repeats</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">opt_kwds</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span> <span class="n">rbf_kwds</span><span class="o">=</span><span class="nb">dict</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;Optimize :class:`Rbf`&#39;s hyper-parameter :math:`p` or both :math:`(p,r)`.</span>

<span class="sd">    Use a cross validation error metric or the direct fit error if `cv_kwds` is</span>
<span class="sd">    None. Uses :class:`FitError`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points, values : see :class:`Rbf`</span>
<span class="sd">    method : str</span>
<span class="sd">        | &#39;de&#39; : :func:`scipy.optimize.differential_evolution`</span>
<span class="sd">        | &#39;fmin&#39;: :func:`scipy.optimize.fmin`</span>
<span class="sd">        | &#39;brute&#39;: :func:`scipy.optimize.brute`</span>
<span class="sd">    what : str</span>
<span class="sd">        &#39;p&#39; (optimize only `p` and set `r=None`) or &#39;pr&#39; (optimize `p` and `r`)</span>
<span class="sd">    cv_kwds, rbf_kwds : see :class:`FitError`</span>
<span class="sd">    opt_kwds : dict</span>
<span class="sd">        kwds for the optimizer (see `method`)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rbfi : :class:`Rbf`</span>
<span class="sd">        Rbf instance initialized with `points`, `values` and found optimal `p` (and `r`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">what</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;pr&#39;</span><span class="p">],</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;unknown `what` value: </span><span class="si">{what}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;de&#39;</span><span class="p">,</span> <span class="s1">&#39;fmin&#39;</span><span class="p">,</span> <span class="s1">&#39;brute&#39;</span><span class="p">],</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;unknown `method` value: </span><span class="si">{method}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">fit_err</span> <span class="o">=</span> <span class="n">FitError</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">cv_kwds</span><span class="o">=</span><span class="n">cv_kwds</span><span class="p">,</span> <span class="n">rbf_kwds</span><span class="o">=</span><span class="n">rbf_kwds</span><span class="p">)</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">estimate_p</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">disp</span> <span class="o">=</span> <span class="n">opt_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;disp&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;fmin&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">opt_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;x0&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">p0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s1">&#39;pr&#39;</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">opt_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;x0&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">p0</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">])</span>
        <span class="n">xopt</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">fit_err</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span>
                             <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="o">**</span><span class="n">opt_kwds</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;de&#39;</span><span class="p">,</span> <span class="s1">&#39;brute&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="n">_bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">p0</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s1">&#39;pr&#39;</span><span class="p">:</span>
            <span class="n">_bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">p0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1e-12</span><span class="p">,</span> <span class="mf">1e-1</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;de&#39;</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">opt_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="n">_bounds</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">differential_evolution</span><span class="p">(</span><span class="n">fit_err</span><span class="p">,</span>
                                                  <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                                                  <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">opt_kwds</span><span class="p">)</span>
            <span class="n">xopt</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">x</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;brute&#39;</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">opt_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ranges&#39;</span><span class="p">,</span> <span class="n">_bounds</span><span class="p">)</span>
            <span class="n">xopt</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">brute</span><span class="p">(</span><span class="n">fit_err</span><span class="p">,</span>
                                  <span class="n">ranges</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                                  <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">opt_kwds</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s1">&#39;pr&#39;</span><span class="p">:</span>
        <span class="n">rbfi</span> <span class="o">=</span> <span class="n">Rbf</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">xopt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="o">=</span><span class="n">xopt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rbfi</span> <span class="o">=</span> <span class="n">Rbf</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">xopt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">rbfi</span></div>
</pre></div>

          </div>
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2020, Steve Schmerler.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
    </div>

    

    
  </body>
</html>